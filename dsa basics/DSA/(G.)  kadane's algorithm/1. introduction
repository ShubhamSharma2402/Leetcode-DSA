kadane's algorithm:-

âŒ Brute Force (What we avoid)
Check all subarrays

Time: O(nÂ²) or O(nÂ³)

âœ… Kadaneâ€™s Algorithm (Optimal)

Time: O(n)

Space: O(1)

ğŸ”¹ Core Intuition (MOST IMPORTANT)

ğŸ‘‰ If the current sum becomes negative, drop it.
Why?
A negative sum will only reduce future subarray sums

Starting fresh gives a better chance

ğŸ”¹ Two Variables Used

currentSum â†’ best sum ending at current index

maxSum â†’ best sum seen so far

*VARIENTS:-

Variant 1: Maximum Subarray with Indices

Variant 2: Minimum Subarray Sum

Variant 3: Circular Subarray Sum

*When to use Kadane?

Use when problem says:

1. â€œMaximum subarrayâ€

2. â€œLargest sum of contiguous elementsâ€

3. â€œBest running segmentâ€

IMPLEMENTATION:-

class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int currentSum = nums[0];
        int maxSum = nums[0];

        for (int i = 1; i < nums.size(); i++) {
            currentSum = max(nums[i], currentSum + nums[i]);
            maxSum = max(maxSum, currentSum);
        }
        return maxSum;
    }
};
